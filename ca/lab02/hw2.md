### Домашняя работа 2###
#### Основная часть ####
##### Задача 1 ######
Решим задачу простым делением числа на 2 и записыванием остатков справа-налево.
Unsigned: 0 - 000000, 13 - 001101, 24 - 011000, 63 - 111111\
Signed: 16 - 010000, -2 - 100010, 31 - 011111, -32 - 100000
##### Задача 2 ######
Unsigned variant: $000101 = 2^{0} + 2^{2} = 5$, $101011 = 2^{0} + 2^{1} + 2^{3} + 2^{5} = 43$, $111111 = 2^{0} + 2^{1}+ 2^{2}+ 2^{3}+ 2^{4}+ 2^{5} = 63$, $100000 = 2^{5} = 32$\
Signed variant: $000101 = 1*(2^{0} + 2^{2}) = 5$, $101011 = -(010100 + 1)  = -21$, $111111 = -(000000_{2} + 1) = -1$, $100000 = -(011111_{2} + 1) = -32$
##### Задача 3 ######
Просто воспользуемся алгоритмом переведения числа в 16-ричную систему счисления.
$7 = 7$, $240 = F0$, $171 = AB$, $126 = 7E$
##### Задача 4 ######
$0x3C = 12 + 3*16 = 60_{10} = 00111100_{2}$, $0x7E = 14 + 7*16 = 126_{10} = 01111111_{2}$, $0xFF = 15*16 + 15 = 255_{10} = 11111111_{2}$, $0xA5 = 5 + 10*16 = 165_{10} = 10100101_{2}$
##### Задача 5 ######
$neg(00111100_{2}) = 11000100_{2}  , $neg(01111111_{2}) = 10000001_{2}$, $neg(11111111_{2}) = 00000001_{2}$, $neg(10100101_{2}) = 01011011_{2}$
##### Задача 6 ######
Изначально число записано в формате big-endian, записать его в порядке little это то же самое что переставить блоки по два в обратном порядке($2*4 = 8$).\
$DE|AD|BE|EF$ - big-endian
$EF|BE|AD|DE$ - little-endian
##### Задача 7 ######
Сконвертируем в знаковые 5-битные числа:
$7_{10} = 00111_{2}$, $15_{10} = 01111_{2}$, $-16_{10} = 10000_{2}$, $-5_{10} = 11011_{2}$.
Дополним до 8-битовых:
$00000111_{2}$, $00001111_{2}$, $11110000_{2}$, $11111011_{2}$
##### Задача 8 ######
Unsigned: $7_{10} = 0111_{2}, 9_{10} = 1001_{2}, 0111_{2} + 1001_{2} = 0000_{2} = 0$(из-за переполнения, хотя на самом деле должно быть 16)\
Signed: $4_{10} = 0100_{2}, -5_{10} = 1010_{2}, 0100_{2} + 1010_{2} = 1110_{2} = -1$
#### Бонусная часть ####
##### Бонусная задача 12 из классной работы #####
Нужно объяснить как работает следующий битовый трюк:
$x = x \wedge y, y = x \wedge y, x = x \wedge y$, и после этого x и y свапнулись.\
Проще всего объяснить этот трюк через теоретическо множественные операции:
Первая операция оставляет в x только те биты, которые есть или только в x, или только в y.\
Вторая операция уберет из y биты которые есть только в y, и добавит туда биты, которые есть только в x, соответсвенно мы получим изначальный x записанный в y.
Третья операция отработает аналогично второй и в итоге мы получим y записанный в x.\
Разберем один из примеров:\
$x = 0011, y = 1100$\
$x = x \wedge y = 1111$\
$y = x \wedge y = 0011$\
$y = x \wedge y = 1100$\
Да, числа действительно поменялись местами
##### Бонусная задача 16 из классной работы #####
1. x&(x-1)\
Рассмотрим крайний правый единичный бит в x:\
$\dots 1000\dots 0$, после вычитания получим $\dots 0111\dots 1$, начальная часть числа при этом не изменилась.
Соответсвенно логическое и на оставшейся части даст везде нули, и у исходного числа занулится самый правый(от начала) бит.
2. $x | (x+1)$\
Рассмотрим крайний правый нулевой бит в x:\
$\dots 0111\dots 1$, после прибавления получим $\dots 1000\dots 0$, начальная часть числа при этом не изменилась.
Соответсвенно логическое или на оставшейся части даст везде единицы, и у исходного числа крайний правый нулевой бит станет единичным.
3. $x | (x-1)$
Рассмотрим самую правый единичный бит в x:\
$\dots 1000\dots 0$, после вычитания получим $\dots 0111\dots 1$, начальная часть числа при этом не изменилась.
Соответсвенно логическое и на оставшейся части даст везде единицы, и у исходного числа все конечные нулевые биты станут единичными.

